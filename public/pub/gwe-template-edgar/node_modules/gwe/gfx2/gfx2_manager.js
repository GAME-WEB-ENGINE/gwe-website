import { Utils } from '../utils';

class GfxManager {
  private cameraOffset: Array<number>;
  private cameraZoom: number;
  private cameraZoomMax: number;
  private cameraZoomMin: number;
  private viewport: HTMLElement;
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor() {
    this.cameraOffset = [0, 0];
    this.cameraZoom = 1;
    this.cameraZoomMax = 5;
    this.cameraZoomMin = 1;

    this.viewport = <HTMLCanvasElement>document.getElementById('VIEWPORT');
    if (!this.viewport) {
      throw new Error('GfxManager::GfxManager: VIEWPORT not found');
    }

    this.canvas = <HTMLCanvasElement>document.getElementById('CANVAS');
    if (!this.canvas) {
      throw new Error('GfxManager::GfxManager: CANVAS not found');
    }

    this.ctx = <CanvasRenderingContext2D>this.canvas.getContext('2d');
    if (!this.ctx) {
      throw new Error('GfxManager::GfxManager: Your browser not support 2D');
    }
  }

  update(timeStep: number): void {
    if (this.cameraOffset[0] < (this.viewport.clientWidth / this.cameraZoom) / 2) {
      this.cameraOffset[0] = (this.viewport.clientWidth / this.cameraZoom) / 2;
    }

    if (this.cameraOffset[0] > (this.canvas.width - (this.viewport.clientWidth / this.cameraZoom) / 2) ) {
      this.cameraOffset[0] = this.canvas.width - (this.viewport.clientWidth / this.cameraZoom) / 2;
    }

    this.canvas.style.left = -this.cameraOffset[0] + (this.viewport.clientWidth / 2) * this.cameraZoom + 'px';
    this.canvas.style.top = -this.cameraOffset[1] + (this.viewport.clientHeight / 2) * this.cameraZoom + 'px';
    const originX = this.cameraOffset[0] + this.viewport.clientWidth / 2;
    const originY = this.cameraOffset[1] + this.viewport.clientHeight / 2;
    this.canvas.style.transformOrigin = originX + 'px' + ' ' + originY + 'px';
    this.canvas.style.transform = 'scale(' + this.cameraZoom + ')';
  }

  clear(): void {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  getViewportFromClientPosition(clientX: number, clientY: number): Array<number> {
    const rect = this.viewport.getBoundingClientRect();
    const x = clientX - rect.x;
    const y = clientY - rect.y;
    return [x, y]
  }

  getWorldFromClientPosition(clientX: number, clientY: number): Array<number> {
    const rect = this.canvas.getBoundingClientRect();
    const x = ((clientX - rect.x)) / this.cameraZoom;
    const y = ((clientY - rect.y)) / this.cameraZoom;
    return [x, y];
  }

  moveCamera(x: number, y: number): void {
    this.cameraOffset[0] = Utils.CLAMP(this.cameraOffset[0] + x, 0, this.canvas.width * this.cameraZoom - this.viewport.clientWidth);
    this.cameraOffset[1] = Utils.CLAMP(this.cameraOffset[1] + y, 0, this.canvas.height * this.cameraZoom - this.viewport.clientHeight);
  }

  zoomCamera(amount: number): void {
    this.cameraZoom = Utils.CLAMP(this.cameraZoom + amount, this.cameraZoomMin, this.cameraZoomMax);
  }

  setWorldWidth(width: number): void {
    this.canvas.width = width;
    this.canvas.style.width = width + 'px';
  }

  setWorldHeight(height: number): void {
    this.canvas.height = height;
    this.canvas.style.height = height + 'px';
  }

  getWorldWidth(): number {
    return this.canvas.width;
  }

  getWorldHeight(): number {
    return this.canvas.height;
  }

  setCameraOffset(offsetX: number, offsetY: number): void {
    this.cameraOffset[0] = offsetX;
    this.cameraOffset[1] = offsetY;
  }

  setCameraZoom(cameraZoom: number): void {
    this.cameraZoom = Utils.CLAMP(cameraZoom, this.cameraZoomMin, this.cameraZoomMax);
  }

  getCameraOffsetX(): number {
    return this.cameraOffset[0];
  }

  getCameraOffsetY(): number {
    return this.cameraOffset[1];
  }

  getCameraZoom(): number {
    return this.cameraZoom;
  }

  getViewport(): HTMLElement {
    return this.viewport;
  }

  getCanvas(): HTMLCanvasElement {
    return this.canvas;
  }
 
  getContext(): CanvasRenderingContext2D {
    return this.ctx;
  }
}

export const gfxManager = new GfxManager();