import { eventManager } from '../event/event_manager';
import { gfxManager } from './gfx_manager';
import { textureManager } from '../texture/texture_manager';
import { GfxDrawable } from './gfx_drawable';

interface SpriteAnimation {
  name: string;
  frames: Array<SpriteAnimationFrame>;
  frameDuration: number;
}

interface SpriteAnimationFrame {
  x: number;
  y: number;
  width: number;
  height: number;
}

export class GfxSprite extends GfxDrawable {
  private texture: HTMLImageElement;
  private animations: Array<SpriteAnimation>;
  private currentAnimationName: string;
  private currentAnimationFrameIndex: number;
  private isLooped: boolean;
  private timeElapsed: number;

  constructor() {
    super();
    this.texture = textureManager.getDefaultTexture();
    this.animations = [];
    this.currentAnimationName = '';
    this.currentAnimationFrameIndex = 0;
    this.isLooped = false;
    this.timeElapsed = 0;
  }

  setTexture(texture: HTMLImageElement): void {
    this.texture = texture;
  }

  onUpdate(timeStep: number): void {
    const currentAnimation = this.animations.find(a => a.name == this.currentAnimationName);
    if (!currentAnimation) {
      return;
    }

    if (this.timeElapsed >= currentAnimation.frameDuration) {
      if (this.currentAnimationFrameIndex == currentAnimation.frames.length - 1) {
        eventManager.emit(this, 'E_SPRITE_COMPLETED');
        this.currentAnimationFrameIndex = this.isLooped ? 0 : currentAnimation.frames.length - 1;
        this.timeElapsed = 0;
      }
      else {
        this.currentAnimationFrameIndex = this.currentAnimationFrameIndex + 1;
        this.timeElapsed = 0;
      }
    }
    else {
      this.timeElapsed += timeStep;
    }
  }

  onDraw(timeStep: number): void {
    const currentAnimation = this.animations.find(animation => animation.name == this.currentAnimationName);
    if (!currentAnimation) {
      return;
    }

    const currentFrame = currentAnimation.frames[this.currentAnimationFrameIndex];
    const ctx = gfxManager.getContext();

    ctx.drawImage(this.texture, currentFrame.x, currentFrame.y, currentFrame.width, currentFrame.height, 0, 0, currentFrame.width, currentFrame.height);
  }

  play(animationName: string, isLooped: boolean = false, preventSameAnimation: boolean = false): void {
    if (preventSameAnimation && animationName == this.currentAnimationName) {
      return;
    }

    const animation = this.animations.find(animation => animation.name == animationName);
    if (!animation) {
      throw new Error('Sprite::play: animation not found.');
    }

    this.currentAnimationName = animationName;
    this.currentAnimationFrameIndex = 0;
    this.isLooped = isLooped;
    this.timeElapsed = 0;
  }

  async loadFromFile(path: string): Promise<void> {
    const response = await fetch(path);
    const json = await response.json();

    this.animations = [];

    for (const obj of json['Animations']) {
      const animation: SpriteAnimation = {
        name: obj['Name'],
        frames: [],
        frameDuration: parseInt(obj['FrameDuration'])
      };

      for (const objFrame of obj['Frames']) {
        const frame: SpriteAnimationFrame = {
          x: objFrame['X'],
          y: objFrame['Y'],
          width: objFrame['Width'],
          height: objFrame['Height']
        };

        animation.frames.push(frame);
      }

      this.animations.push(animation);
    }

    this.currentAnimationName = '';
    this.currentAnimationFrameIndex = 0;
    this.timeElapsed = 0;
  }
}